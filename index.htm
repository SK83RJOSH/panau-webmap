<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Panau Overview Map</title>
	<script src="http://threejs.org/build/three.min.js"></script>
	<script>
		var dragging, mouseX, mouseY;
		var scene, camera, ambient, shader, renderer;
		var geometry, texture, displacement, uniforms, material, mesh;

		function init() {
			scene = new THREE.Scene();
			scene.fog = new THREE.FogExp2(0xefd1b5, 0.035)

			camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1028);
			camera.position.z = 10;

			shader = THREE.ShaderLib['normalmap'];
			geometry = new THREE.PlaneGeometry(16, 16, 256, 256);
			geometry.computeTangents();
			texture = THREE.ImageUtils.loadTexture('map_diffuse.jpg');
			texture.minFilter = texture.magFilter = THREE.LinearFilter;
			displacement = THREE.ImageUtils.loadTexture('map_displacement.jpg');

			uniforms = THREE.UniformsUtils.clone(shader.uniforms);
			uniforms["enableDiffuse"].value = true;
			uniforms["tDiffuse"].value = texture;
			uniforms["enableDisplacement"].value = true;
			uniforms["tDisplacement"].value = displacement;
			uniforms["uDisplacementScale"].value = 1;
			
			material = new THREE.ShaderMaterial({
				fragmentShader: shader.fragmentShader,
				vertexShader: shader.vertexShader,
				uniforms: uniforms,
				lights: true,
				fog: true
			});

			mesh = new THREE.Mesh(geometry, material);
			mesh.rotation.x = -65 * 0.0174532925;
			scene.add(mesh);

			ambientLight = new THREE.AmbientLight(0xffffff);
			scene.add(ambientLight);

			renderer = new THREE.WebGLRenderer({
				antialias: true
			});
			renderer.setClearColor(0x526f99);
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.physicallyBasedShading = true;

			document.body.appendChild(renderer.domElement);

			renderer.domElement.addEventListener('mousewheel', function(event) {
				camera.position.z -= event.wheelDeltaY * 0.0174532925;
			});

			renderer.domElement.addEventListener('mousedown', function(event) {
				dragging = event.button;

				lastX = event.clientX;
				lastY = event.clientY;
			});

			renderer.domElement.addEventListener('mousemove', function(event) {
				if(dragging === 0) {
					mesh.rotation.z += (lastX - event.clientX) * 0.0174532925;
					mesh.rotation.x += (lastY - event.clientY) * 0.0174532925;
				} else if(dragging === 1) {
					mesh.position.x -= (lastX - event.clientX) * 0.0174532925;
					mesh.position.y += (lastY - event.clientY) * 0.0174532925;
				}

				lastX = event.clientX;
				lastY = event.clientY;
			});

			renderer.domElement.addEventListener('mouseup', function(event) {
				dragging = false;

				lastX = event.clientX;
				lastY = event.clientY;
			});
		}

		function animate() {
			requestAnimationFrame(animate);
			renderer.render(scene, camera);
		}

		window.addEventListener('resize', function() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize(window.innerWidth, window.innerHeight);
		});
	</script>
	<style>
		body, html {
			padding: 0;
			margin: 0;
			overflow: hidden;
		}

		canvas {
			position: fixed;
			width: 100%;
			height: 100%;
		}
	</style>
</head>
<body onload="init(); animate();"></body>
</html>